---
layout: english
title: JPA 2 Query By Example API
comments: true
---
## Query by example with JPA 2

In this post, we present our work on providing Query By Example for JPA 2. 

#### Origin

This feature is originally inspired from [Hibernate Example criterion](https://docs.jboss.org/hibernate/orm/3.6/reference/en-US/html/querycriteria.html#querycriteria-examples
). But since Hibernate's Example is not part of JPA2, we have created our own API, using JPA 2 only.

#### What to expect

We will not cover here QBE implementation details, instead we will explain how to use the Query By Example API generated by Celerio.

The source code implementing Query By Example is included in the 
[repository subpackage](https://github.com/jaxio/generated-projects/blob/master/jsf2-spring-conversation/src/main/generated-java/com/jaxio/appli/repository) 
present in all the projects that SprinFuse/Celerio generates. In this subpackage one part is generic and does not depend on your entities, the other is 
directly related to your entities.

The generated code is `improved regularly` thanks to users' feedbacks.

#### Resources

* <a href="/#gen">Generate a data-oriented application</a> out of your database schema and leverage right away the full power of Query By Example.
* <a href="https://github.com/jaxio/generated-projects">Browse a full generated project code on GitHub</a>
* <a href="https://www.facebook.com/video/video.php?v=524162864265905&notif_t=video_processed">Watch a demo of the generated application</a>
 

### Simple Query By Example

In its simplest form, Query By Example allows you to construct a query from a given entity instance.

Let's assume we have an
[Account entity](https://github.com/jaxio/generated-projects/blob/master/jsf2-spring-conversation/src/main/generated-java/com/jaxio/appli/domain/Account.java) 
having a `lastName` property and that we want to query all accounts whose last name matches 'Jagger'.

Using QBE, constructing the query is as simple as setting the lastName...:

{% highlight java %}
Account example = new Account();
example.setLastName("Jagger");
List<Account> result = accountRepository.find(example);
{% endhighlight %}

At the SQL level, the resulting query looks like this:

	select
	    -- skip other fields for clarity
	    account0_.LAST_NAME as LAST9_3_,
	from
	    Account account0_ 
	where
	    lower(account0_.LAST_NAME)=? limit ?

The [AccountRepository](https://github.com/jaxio/generated-projects/blob/master/jsf2-spring-conversation/src/main/generated-java/com/jaxio/appli/repository/AccountRepository.java)
above is generated by Celerio, it extends a 
[GenericRepository](https://github.com/jaxio/generated-projects/blob/master/jsf2-spring-conversation/src/main/generated-java/com/jaxio/appli/repository/support/GenericRepository.java)
also generated by Celerio.

#### Case sensitivity, order by

The first query above involves a String. Let's change it to make it case sensitive.

Our `Account` entity does not carry case sensitivity meta information. For this reason, we require some extra parameters 
for case sensitivity, but also ordering, etc.
The number of parameters can grow quickly, so we have grouped them in the
[SearchParameters class](https://github.com/jaxio/generated-projects/blob/master/jsf2-spring-conversation/src/main/generated-java/com/jaxio/appli/repository/support/SearchParameters.java) 
which can be passed as a parameter to the accountRepository's methods.

Let's make the first query above `case sensitive` and let's add an `ORDER BY`.

{% highlight java %}
Account example = new Account();
example.setLastName("Jagger"); 
SearchParameters sp = new SearchParameters().caseSensitive().orderBy(OrderByDirection.ASC, Account_.lastName);
List<Account> result = accountRepository.find(example, sp);
{% endhighlight %}

Note the usage of the 
[Account_](https://github.com/jaxio/generated-projects/blob/master/jsf2-spring-conversation/src/main/generated-java/com/jaxio/appli/domain/Account_.java)* 
static metamodel (generated by Celerio), which helps you to keep your query related Java code strongly typed.

At the SQL level, the resulting FROM clause now looks like this:

	from
	    ACCOUNT account0_ 
	where
	    account0_.LAST_NAME=? 
	order by
	    account0_.LAST_NAME asc

#### Pagination

In most web application we need to paginate the query results in order to save resources. In the query below, we retrieve only 
the 3rd page (we assume a page lists 25 rows). The first result is the 50th element and we retrieve at most 25 elements.

{% highlight java %}
Account example = new Account();
example.setLastName("Jagger");
SearchParameters sp = new SearchParameters().caseSensitive().orderBy(OrderByDirection.ASC, Account_.lastName) //
	.first(50).maxResults(25);
List<Account> result = accountRepository.find(example, sp);
{% endhighlight %}

At the SQL level, the resulting FROM clause now looks like this (we use H2 database):

	from
	    ACCOUNT account0_ 
	where
	    account0_.LAST_NAME=? 
	order by
	    account0_.LAST_NAME asc limit ? offset ?


#### LIKE and String

For strings, you can globally control whether a `LIKE` should be used and where the `%` wildcard should be placed. For example, adding :

{% highlight java %}
example.setLastName("Jag")
sp.searchMode(SearchMode.STARTING_LIKE);
{% endhighlight %}

to our example above would result in  

	account0_.LAST_NAME LIKE 'Jag%'


#### Multiple criteria

Until now, we have worked only with one property, lastName, but we can set other properties, for example:

{% highlight java %}
Account example = new Account();
example.setLastName("Jag");
example.setBirthDate(new Date());
SearchParameters sp = new SearchParameters().caseSensitive().orderBy(OrderByDirection.ASC, Account_.lastName) //
        .first(50).maxResults(25).searchMode(SearchMode.STARTING_LIKE);
List<Account> result = accountRepository.find(example, sp);
{% endhighlight %}

By default, the FROM clause uses a `AND` predicate. 

	from
	    ACCOUNT account0_ 
	where
	    (
	        account0_.LAST_NAME like ?
	    ) 
	    AND account0_.BIRTH_DATE=? 
	order by
	    account0_.LAST_NAME asc limit ? offset ?

To use instead `OR`, proceed as follow:

{% highlight java %}
sp.orMode();
{% endhighlight %}

And this time we get:

	WHERE
	account0_.BIRTH_DATE=? 
	OR account0_.LAST_NAME like ? 

#### Is that all ?

Not really, we have just scratched the surface. For the moment, we have covered only rather simple queries.
While simplicity is key, it is often not sufficient. What about date or number range queries ?  What about associated entities ? etc.

### Beyond Query By Example

#### Mixing Query by Example and Range Query.

Now, let's imagine that you also want to restrict the query above to all accounts having their date of birth between 1940 and 1945 included.
Of course, the entity does not have the appropriate property (from & to). 
For this reason, we introduce an additional 
[Range](https://github.com/jaxio/generated-projects/blob/master/jsf2-spring-conversation/src/main/generated-java/com/jaxio/appli/repository/support/Range.java) 
parameter.

Here is an example:

{% highlight java %}
Account example = new Account();
example.setLastName("Jagger");

Calendar from = Calendar.getInstance(); from.set(1940, 0, 1);        
Calendar to = Calendar.getInstance(); to.set(1945, 11, 31);

Range<Account, Date> birthDateRange = Range.newRange(Account_.birthDate);
birthDateRange.from(from.getTime()).to(to.getTime());

List<Account> result = accountRepository.find(example, new SearchParameters().range(birthDateRange));
{% endhighlight %}

Note that you can add ranges of any type: Integer, Long, LocalDate (joda time), BigDecimal, etc...

This codes leads in fine to following FROM clause:

	from
	    ACCOUNT account0_ 
	where
	    (
	        account0_.BIRTH_DATE between ? and ?
	    ) 
	    and account0_.LAST_NAME=?


#### Query all string properties in a OR clause

To find all entities having at least one of their String property matching a given value, use the `searchPattern` method.

Here is an example: 

{% highlight java %}    
SearchParameters sp = new SearchParameters().searchMode(SearchMode.STARTING_LIKE).searchPattern("Jag");
List<Account> result = accountRepository.find(sp);
{% endhighlight %}

The FROM clause now includes all string columns:

	from
	    ACCOUNT account0_ 
	where
	    account0_.EMAIL like ? 
	    or account0_.LAST_NAME like ? 
	    or account0_.LOGIN like ? 
	    or account0_.FIRST_NAME like ? 
	    or account0_.DESCRIPTION like ?


#### Property Selector

In order to construct a `OR` clause for a given property we use the `PropertySelector` class.

Here is an example:

{% highlight java %}    
PropertySelector<Account, String> lastNameSelector = PropertySelector.newPropertySelector(Account_.lastName);
lastNameSelector.setSelected(Arrays.asList("jagger", "richards", "jones", "watts", "taylor", "wyman", "wood"));
SearchParameters sp = new SearchParameters().property(lastNameSelector);
List<Account> result = accountRepository.find(sp);
{% endhighlight %}

Here is the corresponding FROM clause: 

	from
	    ACCOUNT account0_ 
	where
	    account0_.LAST_NAME='jagger'
	    or account0_.LAST_NAME='richards'
	    or account0_.LAST_NAME='jones'
	    or account0_.LAST_NAME='watts'
	    or account0_.LAST_NAME='taylor'
	    or account0_.LAST_NAME='wyman'
	    or account0_.LAST_NAME='wood'

Note that if you use JSF2 with PrimeFaces, you can directly pass a `PropertySelector` to a multiple autoComplete component's value property.
This way, the autoComplete component fills the PropertySelector. Here is how:

	<p:autoComplete ... multiple="true" value="#{accountSearchForm.lastNameSelector.selected}" ... />

Here is a snapshot:

![property selector](/images/blog/2012-09-05/property-selector.png)

PrimeFaces uses the `setSelected(List<Account> selection)` method to fill the lastNameSelector.

#### Mix it all

Remember, you can mix all the example we have seen so far.
You can have in a single query having multiple ranges, multiple property selector, multiple properties set on the example entity, etc.

This gives you great power ;-)

#### Query By Example on association

Let's assume the `Account` entity has a `@ManyToOne` association with the `Address` entity.

Here is how we can retrieve all accounts pointing to an Address having its `city` property set to "Paris":

{% highlight java %}    
Account example = new Account();
example.setHomeAddress(new Address());
example.getHomeAddress().setCity("Paris");
List<Account> result = accountRepository.find(example);
{% endhighlight %}

The FROM clause uses a JOIN:

	from
	    ACCOUNT account0_ cross 
	join
	    ADDRESS address1_ 
	where
	    account0_.ADDRESS_ID=address1_.ID 
	    and address1_.CITY='Paris'


Enjoy!

The SpringFuse/Jaxio team.