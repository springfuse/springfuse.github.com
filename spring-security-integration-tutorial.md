---
layout: english
title: Spring Security Integration Tutorial 
---

<a name="conventions-spring-security-integration"></a>
Spring Security Integration
---------------------------

The generated `UserDetailsServiceImpl` service is the link between the SpringSecurity's world
and your user's credential information. As you expect, this class must know how to
access the user's login and password.

The generated implementation of this service varies depending on whether you follow
or not Celerio's conventions.

If your login credential are stored in your database, then you should make sure that the entity 
playing the role of the `account` entity has the properties expected by Celerio (e.g. login &amp; password).

Once Celerio has found your account entity, it looks up the account entity's many to many associations.
If it finds a many to many association whose target entity is also playing the role
of a `Role` entity (e.g. it has an 'authority' property), then it uses it.

> **Note**
>
> The 'Account' and the 'Role' entities do not need to be named Account and Role.

<a name="conventions-account-entity"></a>
### The Account entity

By convention, Celerio considers that an entity is the `Account` entity if it has the following properties:

<table class="table table-bordered table-striped">
  <thead>
    <tr>
      <th>Expected property</th>
      <th>Type</th>
      <th>Required?</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
  <tr>
    <td>username, login, userName, identifiant, email, emailAddress, mail</td>
    <td>String</td>
    <td>Yes</td>
    <td>Login used by the end user to authenticate to this web application</td>
  </tr>
  <tr>
    <td>password, pwd, passwd, motDePasse</td>
    <td>String</td>
    <td>Yes</td>    
    <td>Password (in clear) used by the end user to authenticate to this web application</td>
  </tr>
  <tr>
    <td>enabled, isEnabled</td>
    <td>Boolean</td>
    <td>No</td>    
    <td>Only enabled users (enabled == true) can login.</td>
  </tr>
  </tbody>
</table>

Bear in mind that you can match this convention using Celerio configuration.
Let's assume that your users' credentials are stored in a table named
User that has 2 columns user_login and user_password.

Such a table would not be considered by default as the account table.

To have Celerio consider this table as the account table, you must map the 
user_login and user_password to one of the expected properties, for example:

{% highlight sql %}
<entityConfig tableName="USER">
	<columnConfigs>
		<columnConfig columnName="user_login" fieldName="username" />
		<columnConfig columnName="user_password" fieldName="password" />
	</columnConfigs>
</entityConfig>	
{% endhighlight %}

> **Note**
>
> If no `Account` entity is found, the `UserDetailsServiceImpl` simply returns hard coded users and roles.


<a name="conventions-role-entity"></a>
The 'Role' entity
----------------

By convention, Celerio considers that an entity is the `Role` entity if it has the following property:

<table class="table table-bordered table-striped">
  <thead>
    <tr>
      <th>Expected property</th>
      <th>Type</th>
      <th>Required</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>  
  <tr>
    <td>authority, roleName, role, nameLocale</td>
    <td>String</td>
    <td>Yes</td>
    <td>The role name for example: ROLE_USER, ROLE_ADMIN</td>
   </tr>
  </tbody>   
</table>

By default, the configuration file generated by Springfuse expects the content 
of the 'authority' column (or one of its variants) to match one of these role names:

* ROLE_USER
* ROLE_ADMIN

This is just a convention coming from Security's official documentation, if it does not suit your needs,
you can change it manually in the files that uses these role names.


Here is a sample SQL script (H2 Database) that complies to Celerio conventions

{% highlight sql %}

CREATE TABLE ACCOUNT (
    account_id char(32) not null, 
    login varchar(255) not null,
    password varchar(255) not null,
    email varchar(255) not null,

    constraint account_unique_1 unique (login),
    constraint account_unique_2 unique (email),
    primary key (account_id)
);

CREATE TABLE ROLE (
    role_id smallint generated by default as identity,
    name_locale varchar(255) not null,

    constraint role_unique_1 unique (name_locale),
    primary key (role_id) 
);

CREATE TABLE ACCOUNT_ROLE (
    account_id char(32) not null,
    role_id smallint not null,

    constraint account_role_fk_1 foreign key (account_id) references ACCOUNT,
    constraint account_role_fk_2 foreign key (role_id) references ROLE,
    primary key (account_id, role_id) 
);

{% endhighlight %}
